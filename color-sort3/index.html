<html>
    <head>
        <link rel="manifest" href="manifest.json" />
        <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
        <style>

*
{
    box-sizing: border-box;
    user-select: none;
    -webkit-user-select: none;

    /* can I do this? */
    touch-action: none;
}

html
{
    width: 100%;
    height: 100%;
}

body
{
    margin: 0;
    overflow: hidden;
    /*
    width: 100vw;
    height: 100vh;
    */
}

#game
{
    --width-unit: 0.1vw;

    --min-bright: 0.25;
    --c: 0.08;

    /*
    --fx: calc(exp(-1 * pow(var(--sweep, -0.2) - var(--b, -0.2), 2) / (2 * pow(var(--c, 0.04), 2))));
    --Dx: calc((1 - var(--min-bright)) * (min(var(--sweep, -0.2) - var(--b, -0.2), 0) / (var(--sweep, -0.2) - var(--b, -0.2))) + 1);
    --brightness: calc(2 + var(--Dx, 1) * (var(--fx) - 1));
    */

    touch-action: none;
    width: 100%;
    height: 100%;
    display: flex;
    flex-direction: column;
}

/*
https://stackoverflow.com/questions/8720931/can-css-detect-the-number-of-children-an-element-has
*/
.in-place:first-child:nth-last-child(50),
.in-place:first-child:nth-last-child(50) ~ .in-place
{
    filter: brightness(var(--brightness));
}

#tray > div#main
{
    outline: 2em solid black;
}

#main, #effects-overlay, #main-backdrop
{
    position: absolute;
    width: calc(var(--width-unit) * 1000);
    height: calc(var(--width-unit) * 500);
    margin: auto;
    left: calc(50vw - var(--width-unit) * 500);
    top: calc(50vh - var(--width-unit) * 250);
    z-index: 2; /* for main */
    /*
    background-image: linear-gradient(black, white);
    */
}

#effects-overlay, #main-backdrop
{
    /*
    width: 100%;    
    height: 100%;
    position: absolute; /* overwrites above rule shared with #main 
    top: 0;
    left: calc(50% - var(--width-unit) * 1000 / 2); /* width / 2 
    */
    pointer-events: none;
    z-index: 11; /* for effects-overlay */
}

#main-backdrop
{
    z-index: 1;
  /*
  background-image: url(color_gradient.png);
  background-size: cover;
  */
  position: absolute;
  /*
  filter: sepia(50%) opacity(50%);
  */
}

/*

@keyframes pulse
{
    from
    {
        filter: brightness(80%);
    }
    to
    {
        filter: brightness(133%);
    }
}


.in-place
{
    animation: 1s pulse ease-in-out alternate infinite;
}

*/

#tray
{
    flex: 1;

    /* thanks to https://stackoverflow.com/a/35362074 for this so I didn't have to think about it */
    /*
    background-image: linear-gradient(45deg, #CCCCCC 25%, transparent 25%), linear-gradient(-45deg, #CCCCCC 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #CCCCCC 75%), linear-gradient(-45deg, transparent 75%, #CCCCCC 75%);
    background-size: 20px 20px;
    background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
    */
}


/*
.bordered, #main
{
    --shadow-width: 1px;
    filter: 
    drop-shadow( var(--shadow-width) var(--shadow-width) calc(var(--shadow-width) * 2) black) 
    drop-shadow( calc(var(--width-unit) * 1) 0px 0px black) 
    drop-shadow( calc(var(--width-unit) * -1)  0px 0px black)
    drop-shadow( 0px calc(var(--width-unit) * 1) 0px black) 
    drop-shadow( 0px calc(var(--width-unit) * -1) 0px black);
}
*/

/* moved to JS
@property --sweep
{
  syntax: '<number>';
  initial-value: 0;
  inherits: true;
}

@keyframes inPlaceFlash {
  from {--sweep: 0.0;}
  to {--sweep: 1.0;}
}
*/

#main
{
    animation: 3s infinite inPlaceFlash;
}

.dragitem
{
    position: absolute;
}

.dropzone
{
    position: relative;
    display: inline-block;
    outline: 1px solid black;
}

.dropzone-active
{
    outline: 0.3em solid rgba(255, 100, 100, 0.5);
}

.dragitem-dragging
{
    /*
    transform: scale(300%);
    */

    z-index: 10;
}

#tray
{
    --dragging: drop-shadow(black 0 0 .3em)
}

#tray:has(.dragitem.dragitem-dragging)
{
    --dragging: initial;
}

#tray > .dragitem
{
    filter: var(--dragging);
}

#tray .dragitem.dragitem-dragging
{
    background-image: initial;
    outline: initial;
    filter: initial;
}

/*
@media (max-width: 999px)
{
    #game
    {
        --width-unit: 0.1vw;
    }
}
*/

@media (max-height: 100vw)
{
    #game
    {
        --width-unit: 0.1vh;
    }
}

</style>
</head>

<body>
    
    <canvas id="first" class="dragitem bordered"  data-role="dragitem"></canvas>

    <div id="game">
        <div id="tray" class="dropzone" data-role="dropzone">
            <div id="main-backdrop"></div>
            <div id="main" class="dropzone" data-role="dropzone">
            </div>
            <canvas id="effects-overlay" width="1000" height="500"></canvas>
        </div>
    </div>
    
    <script>

// get options from URL

options = new URLSearchParams(document.location.search);
        
let game = document.querySelector("#game");
const overlay = document.querySelector("#effects-overlay");
const overlay_ctx = overlay.getContext("2d");

let mainDiv = document.querySelector("#main");
let tray = document.querySelector("#tray");

let gameState = {};

let inplace_count = 0;

let sweep_el = game;
//let sweep_el = document.body;

function start_sweep()
{
    /* set up sweep animation */
    let start_sweep = -0.2;
    let sweep = start_sweep;
    
    const firstInt = setInterval( () =>
        {
            sweep += 0.01;
            if (sweep > 1.2)
            {
                sweep = start_sweep;
                setInterval( () =>
                {
                    sweep += 0.01;
                    if (sweep > 4) //1.2) // 4 adds a little delay
                        sweep = start_sweep
                    sweep_el.style.setProperty("--sweep", sweep);
                }, 13);
                clearInterval(firstInt);
            }
            sweep_el.style.setProperty("--sweep", sweep);
        }, 13);
}

game.addEventListener("contextmenu",
    e =>
    {
        if (e.target.classList.contains("dragitem"))
        {
            let curRot = e.target.dataset.rot ? Number(e.target.dataset.rot) : 0;
            curRot = (curRot + 90) % 360;
            e.target.dataset.rot = curRot;
            e.target.style.transform = `rotate(${curRot}deg)`;
            e.preventDefault();
            //return false;
        }
    });

game.addEventListener("pointerdown",
    e =>
    {
        //console.log("pd", e);

        // rotate on drag and tap

        e.preventDefault();

        if (gameState.dragging)
        {
            let t = gameState.dragging;
            let curRot = t.dataset.rot ? Number(t.dataset.rot) : 0;
            curRot = (curRot + 90) % 360;
            t.dataset.rot = curRot;
            t.style.transform = `rotate(${curRot}deg)`;
            return;
        }

        let role = e.target.dataset.role;

        if (role == "dragitem")
        {
            // not used?:
            const x = e.offsetX;
            const y = e.offsetY;

            var alphaVal;

            /*
            try
            {
                const pixel = e.target.getContext("2d").getImageData(x, y, 1, 1);
                alphaVal = pixel.data[3];
            }
            catch
            */
            {
                alphaVal = 255;
            }

            if ( alphaVal > 200 )
            {
                // done above:
                //e.preventDefault();

                // turns out, not needed:
                //game.setPointerCapture(e.pointerId);

                gameState.dragging = e.target;

                gameState.mainPointerId = e.pointerId;

                //console.log(gameState.dragging.classList);
                gameState.dragging.classList.add("dragitem-dragging");
                
                if (gameState.dragging.classList.contains("in-place"))
                {
                    gameState.dragging.classList.remove("in-place");
                    inplace_count--;
                }
                gameState.start = {x: e.pageX, y: e.pageY};
                
                // find the difference between the actual offset and the transformed offset
                
                let br = e.target.getBoundingClientRect();
                
                // should not be needed:
                e.target.dataset.x = e.target.offsetLeft;
                e.target.dataset.y = e.target.offsetTop;



                e.target.cached_style = e.target.getAttribute("style");
            }
        }
        else
        {
            if (gameState.clickCount)
                gameState.clickCount++;
            else
                gameState.clickCount = 1;

            if (gameState.resetClickCount)
                clearTimeout(gameState.resetClickCount)

            gameState.resetClickCount = setTimeout(() => gameState.clickCount = 0, 500);

            if (gameState.clickCount == 5)
            {
                let mbr = mainDiv.getBoundingClientRect();
                mbr.top -= 20;
                mbr.left -= 20;
                mbr.bottom += 20;
                mbr.right += 20;

                Array.from(tray.children).forEach(
                item =>
                {
                    if (item.classList.contains("dragitem"))
                    {
                        do
                        {
                            let left = Math.random();
                            let top = Math.random();
                            
                            item.style.left = `calc((100% - ${item.width} * var(--width-unit)) * ${left})`;
                            item.style.top = `calc((100% - ${item.height} * var(--width-unit)) * ${top})`;
                            ibr = item.getBoundingClientRect();
                        }
                        while (!(mbr.right < ibr.left || 
                            mbr.left > ibr.right || 
                            mbr.bottom < ibr.top || 
                            mbr.top > ibr.bottom));
                    }
                });
            }
        }
    }
);

game.addEventListener("pointermove",
    e =>
    {
        if (!gameState.dragging || e.pointerId != gameState.mainPointerId) return;

        //console.log("pm", e.target.dataset.role, e);

        var drawSnap = false;
                
        let t = gameState.dragging;
        let td = t.dataset;

        let hits = document.elementsFromPoint(e.clientX, e.clientY);
        
        if (hits.includes(mainDiv))
        {
            gameState.dragging.classList.remove("bordered");

            let x = getLeft(gameState.dragging) - mainDiv.offsetLeft;
            let y = getTop(gameState.dragging) - mainDiv.offsetTop;

            let drag_x = (x / mainDiv.offsetWidth) * 1000;
            let drag_y = (y / mainDiv.offsetHeight) * 500;

            if (Math.abs(drag_x - td.x1) < 50 && Math.abs(drag_y - td.y1) < 50)
            {
                drawSnap = true;
            }
        }

        if (drawSnap)
        {
            if (!gameState.snap_to)
            {
                overlay_ctx.lineWidth = 5;
                overlay_ctx.strokeStyle = "red";
                overlay_ctx.beginPath();
                overlay_ctx.moveTo(td.ulx, td.uly);
                overlay_ctx.lineTo(td.urx, td.ury);
                overlay_ctx.lineTo(td.lrx, td.lry);
                overlay_ctx.lineTo(td.llx, td.lly);
                overlay_ctx.closePath();
                overlay_ctx.stroke();

                gameState.snap_to = gameState.dragging;
            }
        }
        else if (gameState.snap_to)
        {
            //console.log("clearing", overlay_ctx.clearRect);

            // why why why is this needed? (also older safari doesn't have it)
            if (overlay_ctx.reset)
                overlay_ctx.reset();
            overlay_ctx.clearRect(0, 0, overlay.width, overlay.height);

            gameState.snap_to = null;
        }

        /*
        if (Number(t.dataset.x) + (e.pageX - gameState.start.x) < 0)
            t.style.left = "0px";
        else
        */

            t.style.left = `${Number(t.dataset.x) + (e.pageX - gameState.start.x)}px`;
        t.style.top = `${Number(t.dataset.y) + (e.pageY - gameState.start.y)}px`;
    }
);

function getTop(elem)
{
    let rect = elem.getBoundingClientRect();
    return rect.top + window.scrollY;
}

function getLeft(elem)
{
    let rect = elem.getBoundingClientRect();
    return rect.left + window.scrollX;
}

game.addEventListener("pointercancel",
    e =>
    {
        //game.releasePointerCapture(e.pointerId);
        gameState.dragging.setAttribute("style", gameState.dragging.cached_style);
        gameState.dragging = null;
    });

game.addEventListener("pointerup",
    e =>
    {
        //console.log("pu", e.target.dataset.role, e);

        //game.releasePointerCapture(e.pointerId);

        //let role = e.target.dataset.role;

        // only do anything if this was the first touch point
        // might be able to use e.isPrimary?
        if (e.pointerId != gameState.mainPointerId) return;

        let hits = document.elementsFromPoint(e.clientX, e.clientY);

        let t = gameState.dragging;

        
        if (hits.includes(mainDiv))
            var d = mainDiv;
        else
            var d = tray;

        if (!t) return;

        gameState.dragging = null;

        //debugger;

        //let x = t.offsetLeft - d.offsetLeft;
        
        t.classList.remove("dragitem-dragging");

        // untransform to get real position
        let rc = t.style.transform;
        t.style.transform = "";

        let x = getLeft(t) - d.offsetLeft;
        let y = getTop(t) - d.offsetTop;

        t.style.transform = rc;
        
        //console.log(d.offsetWidth, d.offsetHeight);

        if (gameState.snap_to)
        {
            x = t.dataset.x1 * (d.offsetWidth / 1000);
            y = t.dataset.y1 * (d.offsetHeight / 500);
            gameState.snap_to = null;

            if (overlay_ctx.reset)
                overlay_ctx.reset();
            overlay_ctx.clearRect(0, 0, overlay.width, overlay.height);

            t.classList.add("in-place");
            inplace_count++;

            if (inplace_count == 50)
            {
                start_sweep();
            }
        }
        /* moved to pointerdown
        else
            t.classList.remove("in-place");
            */
        
        t.style.left = `calc((${x} / ${d.offsetWidth}) * 100%)`;
        t.style.top = `calc((${y} / ${d.offsetHeight}) * 100%)`;

        d.append(t);
    }
);

window.addEventListener("resize",
    e =>
    {
        let mbr = mainDiv.getBoundingClientRect();
        mbr.top -= 20;
        mbr.left -= 20;
        mbr.bottom += 20;
        mbr.right += 20;

        Array.from(tray.children).forEach(
         item =>
         {
            if (item.classList.contains("dragitem"))
            {
                var ibr = item.getBoundingClientRect();

                while (!(mbr.right < ibr.left || 
                    mbr.left > ibr.right || 
                    mbr.bottom < ibr.top || 
                    mbr.top > ibr.bottom))
                {
                    let left = Math.random();
                    let top = Math.random();

                    item.style.left = `calc((100% - ${item.width} * var(--width-unit)) * ${left})`;
                    item.style.top = `calc((100% - ${item.height} * var(--width-unit)) * ${top})`;
                    ibr = item.getBoundingClientRect();
                }
            }
        });
    });

const puzzle_piece_size = 100;

const puzzleImg = new Image();
puzzleImg.src = "color_gradient.png";
puzzleImg.onload =
    e =>
    {
    let first = document.querySelector("#first");

        var pointCols = [];

        for (var x = 0; x <= 1000; x += puzzle_piece_size)
        {
            var pointCol = [];

            for (var y = 0; y <= 500; y += puzzle_piece_size)
            {
                var point = {x, y};

                pointCol.push(point);
            }

            pointCols.push(pointCol);
        }

        // go rects

        for (var x = 0; x < pointCols.length - 1; x++)
        {
            var leftCol = pointCols[x];
            var rightCol = pointCols[x + 1];

            for (var y = 0; y < pointCol.length - 1; y++)
            {
                // create puzzle piece element
                let item = first.cloneNode(false);

                var ul = leftCol[y];
                var ur = rightCol[y];
                var ll = leftCol[y + 1];
                var lr = rightCol[y + 1];

                // store rect in lower-right vertex
                // to access in next iteration
                // NW indicates the relative location of this rect to the point

                lr.NW_item = item

                // use X_egde = [-1, 1] to indicate if the knob should be in or out
                item.E_edge = Math.round(Math.random()) * 2 - 1;
                item.S_edge = Math.round(Math.random()) * 2 - 1;

                item.edges = {}

                if ( x < pointCols.length - 2 )
                {
                    item.edges.E_edge = Math.round(Math.random()) * 2 - 1;
                    item.dataset.E_edge = item.edges.E_edge
                }

                if ( y < pointCol.length - 2 )
                {
                    item.edges.S_edge = Math.round(Math.random()) * 2 - 1;
                    item.dataset.S_edge = item.edges.S_edge
                }

                
                if (x > 0)
                {
                    var borderer = ll.NW_item
                    item.edges.W_edge = borderer.edges.E_edge
                    item.dataset.W_edge = item.edges.W_edge
                }

                if (y > 0)
                {
                    var borderer = ur.NW_item
                    item.edges.N_edge = borderer.edges.S_edge
                    item.dataset.N_edge = item.edges.N_edge
                }

                // knobs
                var knob_r = 20 // radius
                var knob_d = knob_r * 2

                // set top-left and bottom-right corners
                // move them only outward as needed
                var x1 = ul.x;
                if (item.edges.W_edge && item.edges.W_edge < 0)
                    x1 += knob_d * item.edges.W_edge;
                var y1 = ul.y;
                if (item.edges.N_edge && item.edges.N_edge < 0)
                    y1 += knob_d * item.edges.N_edge;

                var x2 = lr.x;
                if (item.edges.E_edge && item.edges.E_edge > 0)
                    x2 += knob_d * item.edges.E_edge;
                var y2 = lr.y;
                if (item.edges.S_edge && item.edges.S_edge > 0)
                    y2 += knob_d * item.edges.S_edge;

                var width = x2 - x1 + 1;
                var height = y2 - y1 + 1;

                item.dataset.x1 = x1;
                item.dataset.y1 = y1;

                item.dataset.ulx = ul.x;
                item.dataset.urx = ur.x;
                item.dataset.llx = ll.x;
                item.dataset.lrx = lr.x;

                item.dataset.uly = ul.y;
                item.dataset.ury = ur.y;
                item.dataset.lly = ll.y;
                item.dataset.lry = lr.y;
                
                /*
                thanks to https://stackoverflow.com/questions/77688427/css-calc-with-abs-and-var-does-not-work-in-chrome-but-firefox-and-safari
                for giving me a solution when I finally figured out (looked up) that abs() is not supported by Chrome
                
                worked in a round-about way, but required abs(), which FF doesn't support at press time
                item.style.setProperty("--Dx_abs", "max(var(--b) - var(--sweep, -0.2), -1 * (var(--b) - var(--sweep, -0.2)))");
                item.style.setProperty("--Dx", "calc((1 - var(--min-bright)) * (max(var(--b) - var(--sweep, -0.2), 0) / var(--Dx_abs)) + 1)");
                */
               

                item.dataset.b = (ul.x + ul.y) / 1500;
                item.style.setProperty("--b", item.dataset.b);

                item.style.setProperty("--fx", "calc(exp(-1 * pow(var(--sweep, -0.2) - var(--b, -0.2), 2) / (2 * pow(var(--c, 0.04), 2))))");
                item.style.setProperty("--brightness", "calc(2 + (var(--fx) - 1))");

                item.width = width;
                item.height = height;

                /*
                item.style.left = `calc((100% - ${width}px) * ${left})`;
                item.style.top = `calc((100% - ${height}px) * ${top})`;
                */


                item.style.width = `calc(${width} * var(--width-unit))`;
                item.style.height = `calc(${height} * var(--width-unit))`;

                // set initial rotation
                let rot = Math.floor(Math.random() * 4) * 90;
                if (rot > 0)
                {
                    item.style.transform = `rotate(${rot}deg)`;
                    item.dataset.rot = rot;
                }

                item.removeAttribute("id");
                tray.append(item);

                let mbr = mainDiv.getBoundingClientRect();
                mbr.top -= 20;
                mbr.left -= 20;
                mbr.bottom += 20;
                mbr.right += 20;

                do
                {
                    let left = Math.random();
                    let top = Math.random();

                    item.style.left = `calc((100% - ${width} * var(--width-unit)) * ${left})`;
                    item.style.top = `calc((100% - ${height} * var(--width-unit)) * ${top})`;
                    var ibr = item.getBoundingClientRect();
                }
                while (!(mbr.right < ibr.left || 
                    mbr.left > ibr.right || 
                    mbr.bottom < ibr.top || 
                    mbr.top > ibr.bottom));

                // alignment problem
                // want to shift E and S over and down 1
                // because rect is extended 1 px over and down...
                // but this doesn't match up with
                // the other piece

                // transform origin x and y
                let tox = puzzle_piece_size / 2;
                let toy = puzzle_piece_size / 2;

                const half_size = puzzle_piece_size / 2;
                const knobPos = {
                    N_edge: {x: half_size, y: 0},
                    E_edge: {x: puzzle_piece_size, y: half_size},
                    S_edge: {x: half_size, y: puzzle_piece_size},
                    W_edge: {x: 0, y: half_size}
                }

                if (item.edges.N_edge && item.edges.N_edge < 0)
                {
                    // TODO: use foreach instead?
                    knobPos.N_edge.y += knob_d;
                    knobPos.E_edge.y += knob_d;
                    knobPos.S_edge.y += knob_d;
                    knobPos.W_edge.y += knob_d;

                    // adjust transform origin
                    toy += knob_d;
                }

                if (item.edges.W_edge && item.edges.W_edge < 0)
                {
                    knobPos.N_edge.x += knob_d;
                    knobPos.E_edge.x += knob_d;
                    knobPos.S_edge.x += knob_d;
                    knobPos.W_edge.x += knob_d;

                    // adjust transform origin
                    tox += knob_d;
                }

                item.style.transformOrigin = `${tox*100/width}% ${toy*100/height}%`;

                var ctx = item.getContext("2d");
                ctx.save();
                ctx.beginPath();

                /*
                console.log(ul.x - x1, ul.y - y1);
                console.log(lr.x - x1 + 1, lr.y - y1 + 1);
                console.log(ur.x - x1 + 1, ur.y - y1);
                console.log(ll.x - x1, ll.y - y1 + 1);
                */

                ctx.moveTo(ul.x - x1, ul.y - y1);
                ctx.lineTo(ur.x - x1 + 1, ur.y - y1);
                ctx.lineTo(lr.x - x1 + 1, lr.y - y1 + 1);
                ctx.lineTo(ll.x - x1, ll.y - y1 + 1);
                
                /*
                ctx.moveTo(x1 - ul.x, y1 - ul.y);
                ctx.lineTo(x1 - ur.x + 1, y1 - ur.y);
                ctx.lineTo(x1 - lr.x + 1, y1 - lr.y + 1);
                ctx.lineTo(x1 - ll.x, y1 - ll.y + 1);
                */

                for (var o in knobPos)
                {
                    var e = item.edges[o];
                    if (e)
                    {
                        /*
                        ctx.moveTo(knobPos[o].x + knob_r * e, knobPos[o].y + knob_r * e);
                        ctx.arc(knobPos[o].x + knob_r * e, knobPos[o].y + knob_r * e, knob_r, 0, Math.PI * 2, true)
                        */

                        // edge - axis correlations
                        const edax = {
                            N_edge: "y",
                            E_edge: "x",
                            S_edge: "y",
                            W_edge: "x"
                        }

                        // update the knob position along the appropriate axis for the current edge o
                        knobPos[o][edax[o]] += e * knob_r;

                        ctx.moveTo(knobPos[o].x, knobPos[o].y);
                        ctx.arc(knobPos[o].x, knobPos[o].y, knob_r, 0, Math.PI * 2, true)
                    }
                }

                ctx.clip()
                ctx.drawImage(puzzleImg, x1, y1, width, height, 0, 0, width, height);
                ctx.restore();
            }
        }
        
        // remove base item that got cloned
        first.remove();

        // shuffle
        for (var i = 0; i < tray.children.length; i++)
        {
            var ind = Math.random() * tray.children.length;

            tray.append(tray.children.item(ind));
        }

    };

//scatter();

//showFeedback();

        </script>

        <script type="module" src="app.js"></script>

    </body>
</html>
